<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>YIR Gradient Generator — QF Campaign Toolkit</title>
  
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <style>
    html { scroll-behavior: smooth; }
    
    /* Drop zone styling */
    .drop-zone {
      transition: all 0.2s ease;
    }
    .drop-zone.dragging {
      border-color: #11362A;
      background-color: #F5F5F3;
    }
    
    /* Gradient preview layers */
    .gradient-preview {
      position: relative;
      overflow: hidden;
    }
    .gradient-layer {
      position: absolute;
      inset: -50%;
      filter: blur(20px);
    }
    .gradient-layer-soft-light-1 {
      mix-blend-mode: soft-light;
      top: -20%; /* First soft light layer - higher offset */
    }
    .gradient-layer-soft-light-2 {
      mix-blend-mode: soft-light;
      top: -50%; /* Second soft light layer - matches primary */
    }
  </style>
</head>
<body class="bg-[#FAFAF9]">
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useCallback, useRef, useEffect } = React;

    // =============================================================================
    // YIR GRADIENT GENERATOR — QF CAMPAIGN TOOLKIT
    // =============================================================================

    // Constants
    const BASE_COLOR = '#FFE9D2';
    const WARM_THRESHOLD = 30; // Hue threshold for warm/cool classification

    // Signature Palette - Curated gradient-worthy colors
    const SIGNATURE_PALETTE = {
      purples: [
        { hex: '#B09CF6', name: 'light-purple' },
        { hex: '#D29CF6', name: 'light-purple-warm' },
        { hex: '#4F1BE0', name: 'deep-purple' },
        { hex: '#7642BA', name: 'purple' },
        { hex: '#351D47', name: 'dark-purple' },
        { hex: '#7D66A2', name: 'medium-purple' }
      ],
      teals: [
        { hex: '#4D7B6B', name: 'teal-sage' },
        { hex: '#88CC90', name: 'sage-green' },
        { hex: '#11362A', name: 'sidra-green' },
        { hex: '#2D6A5D', name: 'deep-teal' },
        { hex: '#5BA3A3', name: 'cyan-teal' }
      ],
      // Muted/dark teals for Cool+Earthy strategy (from Figma AI theme)
      mutedTeals: [
        { hex: '#11362A', name: 'sidra-dark' },
        { hex: '#1E4D3D', name: 'forest-teal' },
        { hex: '#2D4A44', name: 'muted-teal' },
        { hex: '#3A5248', name: 'dusty-teal' },
        { hex: '#419B7E', name: 'sage-muted' },
        { hex: '#4A6B5E', name: 'moss' }
      ],
      oranges: [
        { hex: '#FF6B35', name: 'bright-orange' },
        { hex: '#F23A10', name: 'orange-red' },
        { hex: '#E09B1B', name: 'golden-orange' },
        { hex: '#C38F46', name: 'warm-tan' }
      ],
      blues: [
        { hex: '#1B8EE0', name: 'bright-blue' },
        { hex: '#357AAF', name: 'ocean-blue' },
        { hex: '#1A5276', name: 'deep-blue' },
        { hex: '#5DADE2', name: 'sky-blue' }
      ],
      earthy: [
        { hex: '#5E5722', name: 'olive-brown' },
        { hex: '#797B4D', name: 'olive-sage' },
        { hex: '#8B7355', name: 'taupe' },
        { hex: '#A67B5B', name: 'warm-brown' },
        { hex: '#C4A77D', name: 'sand' },
        { hex: '#6B5344', name: 'cocoa' },
        { hex: '#8E7C68', name: 'driftwood' }
      ],
      magentas: [
        { hex: '#E91E63', name: 'magenta' },
        { hex: '#C2185B', name: 'deep-magenta' },
        { hex: '#F48FB1', name: 'soft-pink' }
      ]
    };

    // ─────────────────────────────────────────────────────────────────────────────
    // COLOR UTILITIES
    // ─────────────────────────────────────────────────────────────────────────────

    const hexToRgb = (hex) => {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : null;
    };

    const rgbToHex = (r, g, b) => {
      return '#' + [r, g, b].map(x => {
        const hex = Math.round(x).toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      }).join('').toUpperCase();
    };

    const rgbToHsl = (r, g, b) => {
      r /= 255; g /= 255; b /= 255;
      const max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;

      if (max === min) {
        h = s = 0;
      } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
          case g: h = ((b - r) / d + 2) / 6; break;
          case b: h = ((r - g) / d + 4) / 6; break;
        }
      }
      return { h: h * 360, s: s * 100, l: l * 100 };
    };

    const isWarmColor = (hsl) => {
      // Warm colors: reds, oranges, yellows (roughly 0-60 and 300-360)
      return (hsl.h >= 0 && hsl.h <= 60) || (hsl.h >= 300 && hsl.h <= 360);
    };

    const isCoolColor = (hsl) => {
      // Cool colors: greens, blues, purples (roughly 90-270)
      return hsl.h >= 90 && hsl.h <= 270;
    };

    const colorDistance = (c1, c2) => {
      return Math.sqrt(
        Math.pow(c1.r - c2.r, 2) +
        Math.pow(c1.g - c2.g, 2) +
        Math.pow(c1.b - c2.b, 2)
      );
    };

    const findClosestPaletteColor = (extractedColor, paletteColors) => {
      let minDist = Infinity;
      let closest = paletteColors[0];

      paletteColors.forEach(paletteColor => {
        const paletteRgb = hexToRgb(paletteColor.hex);
        const dist = colorDistance(extractedColor.rgb, paletteRgb);
        if (dist < minDist) {
          minDist = dist;
          closest = paletteColor;
        }
      });

      return {
        ...closest,
        rgb: hexToRgb(closest.hex),
        hsl: rgbToHsl(...Object.values(hexToRgb(closest.hex))),
        distance: minDist
      };
    };

    const mapToSignaturePalette = (extractedColors) => {
      // Flatten signature palette
      const allPaletteColors = [
        ...SIGNATURE_PALETTE.purples,
        ...SIGNATURE_PALETTE.teals,
        ...SIGNATURE_PALETTE.mutedTeals,
        ...SIGNATURE_PALETTE.oranges,
        ...SIGNATURE_PALETTE.blues,
        ...SIGNATURE_PALETTE.earthy,
        ...SIGNATURE_PALETTE.magentas
      ];

      // Map each extracted color to nearest palette color
      const mapped = extractedColors.map(color =>
        findClosestPaletteColor(color, allPaletteColors)
      );

      // Deduplicate (same palette color might be matched multiple times)
      const unique = [];
      mapped.forEach(color => {
        if (!unique.some(u => u.hex === color.hex)) {
          unique.push(color);
        }
      });

      return unique;
    };

    const isNearBlackOrWhite = (rgb) => {
      const brightness = (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
      return brightness < 30 || brightness > 225;
    };

    // ─────────────────────────────────────────────────────────────────────────────
    // COLOR EXTRACTION
    // ─────────────────────────────────────────────────────────────────────────────

    const extractColorsFromImage = (imageData, numColors = 4) => {
      const pixels = [];
      const data = imageData.data;
      
      // Sample every 4th pixel for performance
      for (let i = 0; i < data.length; i += 16) {
        const rgb = { r: data[i], g: data[i + 1], b: data[i + 2] };
        if (!isNearBlackOrWhite(rgb)) {
          pixels.push(rgb);
        }
      }

      // Simple k-means clustering
      if (pixels.length === 0) return [];
      
      // Initialize centroids randomly
      let centroids = [];
      for (let i = 0; i < numColors; i++) {
        centroids.push(pixels[Math.floor(Math.random() * pixels.length)]);
      }

      // Run k-means for 10 iterations
      for (let iter = 0; iter < 10; iter++) {
        const clusters = Array(numColors).fill(null).map(() => []);
        
        // Assign pixels to nearest centroid
        pixels.forEach(pixel => {
          let minDist = Infinity;
          let closestIdx = 0;
          centroids.forEach((centroid, idx) => {
            const dist = colorDistance(pixel, centroid);
            if (dist < minDist) {
              minDist = dist;
              closestIdx = idx;
            }
          });
          clusters[closestIdx].push(pixel);
        });

        // Update centroids
        centroids = clusters.map((cluster, idx) => {
          if (cluster.length === 0) return centroids[idx];
          return {
            r: cluster.reduce((sum, p) => sum + p.r, 0) / cluster.length,
            g: cluster.reduce((sum, p) => sum + p.g, 0) / cluster.length,
            b: cluster.reduce((sum, p) => sum + p.b, 0) / cluster.length
          };
        });
      }

      // Sort by frequency (cluster size would be tracked in real implementation)
      return centroids.map(c => ({
        hex: rgbToHex(c.r, c.g, c.b),
        rgb: c,
        hsl: rgbToHsl(c.r, c.g, c.b)
      }));
    };

    // ─────────────────────────────────────────────────────────────────────────────
    // COLOR CLUSTERING ACROSS IMAGES
    // ─────────────────────────────────────────────────────────────────────────────

    const clusterAllColors = (allColors, numClusters = 3) => {
      if (allColors.length === 0) return [];

      // Step 1: Prioritize high-saturation colors
      const sortedBySaturation = [...allColors].sort((a, b) => b.hsl.s - a.hsl.s);

      // Step 2: Deduplicate similar colors, keeping high-saturation ones
      const uniqueColors = [];
      sortedBySaturation.forEach(color => {
        const isDuplicate = uniqueColors.some(uc => colorDistance(uc.rgb, color.rgb) < 40);
        if (!isDuplicate) {
          uniqueColors.push(color);
        }
      });

      if (uniqueColors.length <= numClusters) {
        // Map to signature palette
        return mapToSignaturePalette(uniqueColors);
      }

      // Step 3: K-means to get 3 distinct dominant colors
      // Initialize with most saturated colors to preserve vibrant tones
      let centroids = uniqueColors.slice(0, numClusters);

      for (let iter = 0; iter < 15; iter++) {
        const clusters = Array(numClusters).fill(null).map(() => []);

        uniqueColors.forEach(color => {
          let minDist = Infinity;
          let closestIdx = 0;
          centroids.forEach((centroid, idx) => {
            const dist = colorDistance(color.rgb, centroid.rgb);
            if (dist < minDist) {
              minDist = dist;
              closestIdx = idx;
            }
          });
          clusters[closestIdx].push(color);
        });

        centroids = clusters.map((cluster, idx) => {
          if (cluster.length === 0) return centroids[idx];

          // Weight by saturation to preserve vibrant colors
          let totalWeight = 0;
          const weightedRgb = { r: 0, g: 0, b: 0 };

          cluster.forEach(c => {
            const weight = c.hsl.s / 100; // Saturation as weight (0-1)
            totalWeight += weight;
            weightedRgb.r += c.rgb.r * weight;
            weightedRgb.g += c.rgb.g * weight;
            weightedRgb.b += c.rgb.b * weight;
          });

          const avgRgb = {
            r: weightedRgb.r / totalWeight,
            g: weightedRgb.g / totalWeight,
            b: weightedRgb.b / totalWeight
          };

          return {
            hex: rgbToHex(avgRgb.r, avgRgb.g, avgRgb.b),
            rgb: avgRgb,
            hsl: rgbToHsl(avgRgb.r, avgRgb.g, avgRgb.b),
            count: cluster.length
          };
        });
      }

      // Step 4: Map k-means results to signature palette
      const mapped = mapToSignaturePalette(centroids);

      // Step 5: Sort by saturation first, then frequency
      return mapped.sort((a, b) => {
        const satDiff = b.hsl.s - a.hsl.s;
        if (Math.abs(satDiff) > 10) return satDiff;
        return (b.count || 0) - (a.count || 0);
      });
    };

    // ─────────────────────────────────────────────────────────────────────────────
    // GRADIENT GENERATION
    // ─────────────────────────────────────────────────────────────────────────────

    const generateGradient = (colors) => {
      if (colors.length === 0) {
        return {
          primaryGradient: 'linear-gradient(180deg, transparent 0%, transparent 100%)',
          softLightGradient1: 'linear-gradient(180deg, transparent 0%, transparent 100%)',
          softLightGradient2: 'linear-gradient(180deg, transparent 0%, transparent 100%)',
          cssOutput: '',
          figmaOutput: ''
        };
      }

      // No saturation boost needed - palette colors are already vibrant!

      // Separate by color family using signature palette
      const purples = colors.filter(c =>
        SIGNATURE_PALETTE.purples.some(p => p.hex === c.hex)
      );
      const teals = colors.filter(c =>
        SIGNATURE_PALETTE.teals.some(t => t.hex === c.hex)
      );
      const oranges = colors.filter(c =>
        SIGNATURE_PALETTE.oranges.some(o => o.hex === c.hex)
      );
      const blues = colors.filter(c =>
        SIGNATURE_PALETTE.blues.some(b => b.hex === c.hex)
      );
      const earthy = colors.filter(c =>
        SIGNATURE_PALETTE.earthy.some(e => e.hex === c.hex)
      );
      const magentas = colors.filter(c =>
        SIGNATURE_PALETTE.magentas.some(m => m.hex === c.hex)
      );

      // Primary layer: Select warm + cool with high contrast
      const warmCandidates = [...oranges, ...earthy, ...magentas];
      const coolCandidates = [...blues, ...teals];

      const primaryColor1 = warmCandidates[0] || coolCandidates[0] || colors[0];
      const primaryColor2 = coolCandidates[0] || warmCandidates[1] || colors[1] || primaryColor1;

      // Soft light layer: MUST include purple + complementary color
      const softColor1 = purples[0] || {
        hex: SIGNATURE_PALETTE.purples[0].hex,
        name: SIGNATURE_PALETTE.purples[0].name,
        rgb: hexToRgb(SIGNATURE_PALETTE.purples[0].hex),
        hsl: rgbToHsl(...Object.values(hexToRgb(SIGNATURE_PALETTE.purples[0].hex)))
      }; // Ensure purple always present
      const softColor2 = coolCandidates[0] || purples[1] || colors[2] || softColor1;

      // Opacity variations: 43%, 56%, 62%, 73%, 77%
      const opacityVariations = [0.43, 0.56, 0.62, 0.73, 0.77];
      const primaryOpacity = opacityVariations[Math.floor(Math.random() * opacityVariations.length)];

      // Primary gradient: Two colors clustered in middle region (44.8% and 57.8%)
      const primaryGradient = `linear-gradient(180deg,
        rgba(249, 249, 247, 0) 0%,
        ${primaryColor1.hex} 45%,
        rgba(${hexToRgb(primaryColor2.hex).r}, ${hexToRgb(primaryColor2.hex).g}, ${hexToRgb(primaryColor2.hex).b}, ${primaryOpacity}) 58%,
        rgba(217, 217, 217, 0) 100%
      )`;

      // TWO soft light gradients at different positions for depth
      const softLightGradient = `linear-gradient(180deg,
        rgba(249, 249, 247, 0) 0%,
        ${softColor1.hex} 15%,
        ${softColor2.hex} 29%,
        rgba(217, 217, 217, 0) 100%
      )`;

      // CSS output with THREE layers
      const cssOutput = `/* YIR Theme Gradient - Three Layer System */
.theme-gradient {
  position: relative;
  background-color: ${BASE_COLOR};
  overflow: hidden;
}

.theme-gradient::before {
  content: '';
  position: absolute;
  inset: -50%;
  filter: blur(20px);
  pointer-events: none;
  background: linear-gradient(180deg,
    rgba(249, 249, 247, 0) 0%,
    ${primaryColor1.hex} 45%,
    rgba(${hexToRgb(primaryColor2.hex).r}, ${hexToRgb(primaryColor2.hex).g}, ${hexToRgb(primaryColor2.hex).b}, ${primaryOpacity}) 58%,
    rgba(217, 217, 217, 0) 100%
  );
}

/* First soft light layer - higher offset */
.theme-gradient::after {
  content: '';
  position: absolute;
  inset: -50%;
  top: -20%;
  filter: blur(20px);
  pointer-events: none;
  background: linear-gradient(180deg,
    rgba(249, 249, 247, 0) 0%,
    ${softColor1.hex} 15%,
    ${softColor2.hex} 29%,
    rgba(217, 217, 217, 0) 100%
  );
  mix-blend-mode: soft-light;
}

/* Add third layer with custom element or additional pseudo-element via wrapper */
.theme-gradient-layer-3 {
  position: absolute;
  inset: -50%;
  filter: blur(20px);
  pointer-events: none;
  background: linear-gradient(180deg,
    rgba(249, 249, 247, 0) 0%,
    ${softColor1.hex} 15%,
    ${softColor2.hex} 29%,
    rgba(217, 217, 217, 0) 100%
  );
  mix-blend-mode: soft-light;
}`;

      // Figma values
      const rgb1 = hexToRgb(primaryColor1.hex);
      const rgb2 = hexToRgb(primaryColor2.hex);
      const srgb1 = hexToRgb(softColor1.hex);
      const srgb2 = hexToRgb(softColor2.hex);

      const figmaOutput = `FIGMA GRADIENT VALUES - THREE LAYER SYSTEM

Base Layer:
  Fill: ${BASE_COLOR} (100%)
  Position: Standard positioning

Layer 1 - Primary Gradient:
  Type: Linear (vertical, 180°)
  Stop 1: F9F9F7 at 0% (0% opacity)
  Stop 2: rgb(${rgb1.r}, ${rgb1.g}, ${rgb1.b}) at 45% (100% opacity)
  Stop 3: rgba(${rgb2.r}, ${rgb2.g}, ${rgb2.b}, ${primaryOpacity}) at 58% (${Math.round(primaryOpacity * 100)}% opacity)
  Stop 4: D9D9D9 at 100% (0% opacity)

Layer 2 - Soft Light (Higher offset):
  Type: Linear (vertical, 180°)
  Blend Mode: Soft Light
  Position: Offset top -20% (asymmetric)
  Stop 1: F9F9F7 at 0% (0% opacity)
  Stop 2: rgb(${srgb1.r}, ${srgb1.g}, ${srgb1.b}) at 15% (100% opacity)
  Stop 3: rgb(${srgb2.r}, ${srgb2.g}, ${srgb2.b}) at 29% (100% opacity)
  Stop 4: D9D9D9 at 100% (0% opacity)

Layer 3 - Soft Light (Standard offset):
  Type: Linear (vertical, 180°)
  Blend Mode: Soft Light
  Position: Standard -50% positioning
  Stop 1-4: Same as Layer 2

Effects:
  Layer Blur: 20px on all gradient layers
  Base offset: -50% on all sides (inset positioning)`;

      return {
        primaryGradient,
        softLightGradient1: softLightGradient,
        softLightGradient2: softLightGradient, // Same gradient, different position
        primaryColor1,
        primaryColor2,
        softColor1,
        softColor2,
        primaryOpacity,
        cssOutput,
        figmaOutput
      };
    };

    const generateGradientVariation = (colors, variationIndex = 0) => {
      if (colors.length === 0) return null;

      // Sort by saturation to prioritize bold colors
      const sortedByVibrance = [...colors].sort((a, b) => b.hsl.s - a.hsl.s);

      // Separate by color family for intelligent pairing
      const purples = colors.filter(c =>
        SIGNATURE_PALETTE.purples.some(p => p.hex === c.hex)
      );
      const teals = colors.filter(c =>
        SIGNATURE_PALETTE.teals.some(t => t.hex === c.hex)
      );
      const oranges = colors.filter(c =>
        SIGNATURE_PALETTE.oranges.some(o => o.hex === c.hex)
      );
      const blues = colors.filter(c =>
        SIGNATURE_PALETTE.blues.some(b => b.hex === c.hex)
      );
      const earthy = colors.filter(c =>
        SIGNATURE_PALETTE.earthy.some(e => e.hex === c.hex)
      );
      const magentas = colors.filter(c =>
        SIGNATURE_PALETTE.magentas.some(m => m.hex === c.hex)
      );

      const warmCandidates = [...oranges, ...earthy, ...magentas];
      const coolCandidates = [...blues, ...teals, ...purples];

      // Create diverse variations by picking from different color groups
      let primaryColor1, primaryColor2;

      // Strategy: Create high-contrast combinations (6 strategies for more diversity)
      const strategy = variationIndex % 6;

      switch(strategy) {
        case 0: // Warm + Cool
          primaryColor1 = warmCandidates[Math.floor(variationIndex / 6) % Math.max(warmCandidates.length, 1)] || sortedByVibrance[0];
          primaryColor2 = coolCandidates[Math.floor(variationIndex / 6) % Math.max(coolCandidates.length, 1)] || sortedByVibrance[1];
          break;
        case 1: // Cool + Warm (reversed)
          primaryColor1 = coolCandidates[Math.floor(variationIndex / 6) % Math.max(coolCandidates.length, 1)] || sortedByVibrance[0];
          primaryColor2 = warmCandidates[Math.floor(variationIndex / 6) % Math.max(warmCandidates.length, 1)] || sortedByVibrance[1];
          break;
        case 2: // Two different cools (blue + teal/purple)
          primaryColor1 = blues[Math.floor(variationIndex / 6) % Math.max(blues.length, 1)] || coolCandidates[0] || sortedByVibrance[0];
          primaryColor2 = [...teals, ...purples][Math.floor(variationIndex / 6) % Math.max([...teals, ...purples].length, 1)] || sortedByVibrance[1];
          break;
        case 3: // Two most saturated (regardless of family)
          primaryColor1 = sortedByVibrance[(variationIndex * 2) % sortedByVibrance.length];
          primaryColor2 = sortedByVibrance[(variationIndex * 2 + 1) % sortedByVibrance.length];
          break;
        case 4: // Cool + Earthy (muted dark teal + brown/taupe) - great for AI theme
          {
            // Use muted, darker teals (from Figma AI theme: #11362A, #419B7E)
            const mutedTeals = colors.filter(c =>
              SIGNATURE_PALETTE.mutedTeals.some(m => m.hex === c.hex)
            );
            // Fallback to curated muted teals if none extracted
            const mutedCoolColors = mutedTeals.length > 0 ? mutedTeals : [
              { hex: '#11362A', name: 'sidra-dark', rgb: hexToRgb('#11362A'), hsl: rgbToHsl(...Object.values(hexToRgb('#11362A'))) },
              { hex: '#2D4A44', name: 'muted-teal', rgb: hexToRgb('#2D4A44'), hsl: rgbToHsl(...Object.values(hexToRgb('#2D4A44'))) },
              { hex: '#419B7E', name: 'sage-muted', rgb: hexToRgb('#419B7E'), hsl: rgbToHsl(...Object.values(hexToRgb('#419B7E'))) }
            ];
            const earthyOnly = earthy.length > 0 ? earthy : [
              { hex: '#8B7355', name: 'taupe', rgb: hexToRgb('#8B7355'), hsl: rgbToHsl(...Object.values(hexToRgb('#8B7355'))) },
              { hex: '#A67B5B', name: 'warm-brown', rgb: hexToRgb('#A67B5B'), hsl: rgbToHsl(...Object.values(hexToRgb('#A67B5B'))) },
              { hex: '#6B5344', name: 'cocoa', rgb: hexToRgb('#6B5344'), hsl: rgbToHsl(...Object.values(hexToRgb('#6B5344'))) }
            ];
            primaryColor1 = mutedCoolColors[Math.floor(variationIndex / 6) % mutedCoolColors.length];
            primaryColor2 = earthyOnly[Math.floor(variationIndex / 6) % earthyOnly.length];
          }
          break;
        case 5: // Magenta/Pink + Teal (vibrant contrast)
          {
            const magentaOrPurple = [...magentas, ...purples];
            const tealOrBlue = [...teals, ...blues];
            primaryColor1 = magentaOrPurple[Math.floor(variationIndex / 6) % Math.max(magentaOrPurple.length, 1)] || {
              hex: '#E91E63', name: 'magenta', rgb: hexToRgb('#E91E63'), hsl: rgbToHsl(...Object.values(hexToRgb('#E91E63')))
            };
            primaryColor2 = tealOrBlue[Math.floor(variationIndex / 6) % Math.max(tealOrBlue.length, 1)] || {
              hex: '#4D7B6B', name: 'teal-sage', rgb: hexToRgb('#4D7B6B'), hsl: rgbToHsl(...Object.values(hexToRgb('#4D7B6B')))
            };
          }
          break;
      }

      // Soft light: ALWAYS purple (brand consistency) + diverse complementary
      const purpleIndex = Math.floor(variationIndex / 2) % SIGNATURE_PALETTE.purples.length;
      const softColor1 = purples[0] || {
        hex: SIGNATURE_PALETTE.purples[purpleIndex].hex,
        name: SIGNATURE_PALETTE.purples[purpleIndex].name,
        rgb: hexToRgb(SIGNATURE_PALETTE.purples[purpleIndex].hex),
        hsl: rgbToHsl(...Object.values(hexToRgb(SIGNATURE_PALETTE.purples[purpleIndex].hex)))
      };

      // Tertiary: Pick from remaining saturated colors
      const remainingColors = sortedByVibrance.filter(c =>
        c.hex !== primaryColor1.hex && c.hex !== primaryColor2.hex
      );
      const softColor2 = remainingColors[variationIndex % remainingColors.length] || primaryColor2;

      // Opacity variations: 43%, 56%, 62%, 73%, 77%
      const opacityVariations = [0.43, 0.56, 0.62, 0.73, 0.77];
      const primaryOpacity = opacityVariations[variationIndex % opacityVariations.length];

      // Primary gradient - adjusted stops for better contrast with base layer
      const primaryGradient = `linear-gradient(180deg,
        rgba(249, 249, 247, 0) 0%,
        ${primaryColor1.hex} 40%,
        rgba(${hexToRgb(primaryColor2.hex).r}, ${hexToRgb(primaryColor2.hex).g}, ${hexToRgb(primaryColor2.hex).b}, ${primaryOpacity}) 65%,
        rgba(217, 217, 217, 0) 100%
      )`;

      // Soft light gradient - push color stops higher for less base layer interference
      const softLightGradient = `linear-gradient(180deg,
        rgba(249, 249, 247, 0) 0%,
        ${softColor1.hex} 12%,
        ${softColor2.hex} 35%,
        rgba(217, 217, 217, 0) 100%
      )`;

      // CSS output
      const cssOutput = `/* YIR Theme Gradient - Three Layer System */
.theme-gradient {
  position: relative;
  background-color: ${BASE_COLOR};
  overflow: hidden;
}

.theme-gradient::before {
  content: '';
  position: absolute;
  inset: -50%;
  filter: blur(20px);
  pointer-events: none;
  background: linear-gradient(180deg,
    rgba(249, 249, 247, 0) 0%,
    ${primaryColor1.hex} 40%,
    rgba(${hexToRgb(primaryColor2.hex).r}, ${hexToRgb(primaryColor2.hex).g}, ${hexToRgb(primaryColor2.hex).b}, ${primaryOpacity}) 65%,
    rgba(217, 217, 217, 0) 100%
  );
}

.theme-gradient::after {
  content: '';
  position: absolute;
  inset: -50%;
  top: -20%;
  filter: blur(20px);
  pointer-events: none;
  background: linear-gradient(180deg,
    rgba(249, 249, 247, 0) 0%,
    ${softColor1.hex} 12%,
    ${softColor2.hex} 35%,
    rgba(217, 217, 217, 0) 100%
  );
  mix-blend-mode: soft-light;
}

.theme-gradient-layer-3 {
  position: absolute;
  inset: -50%;
  filter: blur(20px);
  pointer-events: none;
  background: linear-gradient(180deg,
    rgba(249, 249, 247, 0) 0%,
    ${softColor1.hex} 12%,
    ${softColor2.hex} 35%,
    rgba(217, 217, 217, 0) 100%
  );
  mix-blend-mode: soft-light;
}`;

      // Figma output
      const rgb1 = hexToRgb(primaryColor1.hex);
      const rgb2 = hexToRgb(primaryColor2.hex);
      const srgb1 = hexToRgb(softColor1.hex);
      const srgb2 = hexToRgb(softColor2.hex);

      const figmaOutput = `FIGMA GRADIENT VALUES - THREE LAYER SYSTEM

Base Layer:
  Fill: ${BASE_COLOR} (100%)

Layer 1 - Primary Gradient:
  Type: Linear (vertical, 180°)
  Stop 1: F9F9F7 at 0% (0% opacity)
  Stop 2: rgb(${rgb1.r}, ${rgb1.g}, ${rgb1.b}) at 40% (100% opacity)
  Stop 3: rgba(${rgb2.r}, ${rgb2.g}, ${rgb2.b}, ${primaryOpacity}) at 65% (${Math.round(primaryOpacity * 100)}% opacity)
  Stop 4: D9D9D9 at 100% (0% opacity)

Layer 2 - Soft Light (Higher offset):
  Type: Linear (vertical, 180°)
  Blend Mode: Soft Light
  Position: Offset top -20% (asymmetric)
  Stop 1: F9F9F7 at 0% (0% opacity)
  Stop 2: rgb(${srgb1.r}, ${srgb1.g}, ${srgb1.b}) at 12% (100% opacity)
  Stop 3: rgb(${srgb2.r}, ${srgb2.g}, ${srgb2.b}) at 35% (100% opacity)
  Stop 4: D9D9D9 at 100% (0% opacity)

Layer 3 - Soft Light (Standard offset):
  Type: Linear (vertical, 180°)
  Blend Mode: Soft Light
  Position: Standard -50% positioning
  Stop 1-4: Same as Layer 2

Effects:
  Layer Blur: 20px on all gradient layers
  Base offset: -50% on all sides (inset positioning)`;

      // Strategy labels for UI
      const strategyLabels = [
        'Warm + Cool',
        'Cool + Warm',
        'Dual Cool',
        'Most Vibrant',
        'Cool + Earthy',
        'Magenta + Teal'
      ];

      return {
        id: `gradient-${Date.now()}-${variationIndex}`,
        strategyLabel: strategyLabels[strategy],
        primaryGradient,
        softLightGradient1: softLightGradient,
        softLightGradient2: softLightGradient,
        primaryColor1,
        primaryColor2,
        softColor1,
        softColor2,
        primaryOpacity,
        cssOutput,
        figmaOutput,
        isExpanded: false,
        activeTab: 'css'
      };
    };

    // ─────────────────────────────────────────────────────────────────────────────
    // COMPONENTS
    // ─────────────────────────────────────────────────────────────────────────────

    const ColorChip = ({ color, label }) => (
      <div className="flex items-center gap-2">
        <div 
          className="w-6 h-6 rounded border border-black/10"
          style={{ backgroundColor: color.hex }}
        />
        <div>
          <p className="text-xs text-[#4A7561]">{label}</p>
          <p className="text-xs font-mono text-[#0B241C]">{color.hex}</p>
        </div>
      </div>
    );

    const CopyButton = ({ text, label }) => {
      const [copied, setCopied] = useState(false);
      
      const handleCopy = () => {
        navigator.clipboard.writeText(text);
        setCopied(true);
        setTimeout(() => setCopied(false), 1500);
      };

      return (
        <button
          onClick={handleCopy}
          className="text-xs text-[#4A7561] hover:text-[#0B241C] transition-colors"
        >
          {copied ? 'Copied' : label}
        </button>
      );
    };

    const GradientCard = ({ gradient, onToggleExport, onDelete, onTabChange }) => {
      return (
        <div className="border border-[#E8E8E5] rounded-lg bg-white overflow-hidden">
          {/* Strategy Label */}
          {gradient.strategyLabel && (
            <div className="px-4 py-2 bg-[#F5F5F3] border-b border-[#E8E8E5]">
              <span className="text-xs font-medium text-[#11362A]">{gradient.strategyLabel}</span>
            </div>
          )}

          {/* Gradient Preview */}
          <div
            className="gradient-preview aspect-[4/3]"
            style={{ backgroundColor: BASE_COLOR }}
          >
            <div className="gradient-layer" style={{ background: gradient.primaryGradient }} />
            <div className="gradient-layer gradient-layer-soft-light-1" style={{ background: gradient.softLightGradient1 }} />
            <div className="gradient-layer gradient-layer-soft-light-2" style={{ background: gradient.softLightGradient2 }} />
          </div>

          {/* Color Info */}
          <div className="p-4 space-y-2">
            <p className="text-xs text-[#9AB3A9]">Layer 1: Primary</p>
            <div className="grid grid-cols-2 gap-2">
              <ColorChip color={gradient.primaryColor1} label={gradient.primaryColor1.name} />
              <ColorChip color={gradient.primaryColor2} label={gradient.primaryColor2.name} />
            </div>
            <p className="text-xs text-[#9AB3A9] pt-2">Layers 2 & 3: Soft Light</p>
            <div className="grid grid-cols-2 gap-2">
              <ColorChip color={gradient.softColor1} label={gradient.softColor1.name} />
              <ColorChip color={gradient.softColor2} label={gradient.softColor2.name} />
            </div>
          </div>

          {/* Collapsible Export Toggle */}
          <button
            onClick={() => onToggleExport(gradient.id)}
            className="w-full px-4 py-2 flex items-center justify-between bg-[#F5F5F3] hover:bg-[#E8E8E5] transition-colors text-xs text-[#4A7561]"
          >
            <span>View Export Code</span>
            <span>{gradient.isExpanded ? '▼' : '▶'}</span>
          </button>

          {/* Collapsible Export Section */}
          {gradient.isExpanded && (
            <div className="p-4 border-t border-[#E8E8E5] space-y-3">
              {/* Tabs */}
              <div className="flex gap-4 border-b border-[#E8E8E5]">
                <button
                  onClick={() => onTabChange(gradient.id, 'css')}
                  className={`text-xs pb-2 border-b-2 transition-colors ${
                    gradient.activeTab === 'css'
                      ? 'border-[#11362A] text-[#0B241C]'
                      : 'border-transparent text-[#9AB3A9] hover:text-[#4A7561]'
                  }`}
                >
                  CSS
                </button>
                <button
                  onClick={() => onTabChange(gradient.id, 'figma')}
                  className={`text-xs pb-2 border-b-2 transition-colors ${
                    gradient.activeTab === 'figma'
                      ? 'border-[#11362A] text-[#0B241C]'
                      : 'border-transparent text-[#9AB3A9] hover:text-[#4A7561]'
                  }`}
                >
                  Figma
                </button>
              </div>

              {/* Code Block */}
              <div className="relative">
                <pre className="bg-[#F5F5F3] border border-[#E8E8E5] rounded-lg p-3 text-xs font-mono text-[#4A7561] overflow-x-auto max-h-48 overflow-y-auto">
                  {gradient.activeTab === 'css' ? gradient.cssOutput : gradient.figmaOutput}
                </pre>
                <div className="absolute top-2 right-2">
                  <CopyButton
                    text={gradient.activeTab === 'css' ? gradient.cssOutput : gradient.figmaOutput}
                    label="Copy"
                  />
                </div>
              </div>
            </div>
          )}

          {/* Delete Button */}
          <button
            onClick={() => onDelete(gradient.id)}
            className="w-full px-4 py-2 text-xs text-[#9AB3A9] hover:text-[#4A7561] transition-colors"
          >
            Remove variation
          </button>
        </div>
      );
    };

    // ─────────────────────────────────────────────────────────────────────────────
    // MAIN APP
    // ─────────────────────────────────────────────────────────────────────────────

    function GradientGenerator() {
      const [images, setImages] = useState([]);
      const [extractedColors, setExtractedColors] = useState([]);
      const [clusteredColors, setClusteredColors] = useState([]);
      const [gradients, setGradients] = useState([]);
      const [isDragging, setIsDragging] = useState(false);
      const canvasRef = useRef(null);
      const fileInputRef = useRef(null);

      // Process images when they change
      useEffect(() => {
        if (images.length === 0) {
          setExtractedColors([]);
          setClusteredColors([]);
          setGradients([]);
          return;
        }

        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        const allColors = [];

        let processed = 0;
        images.forEach((imgSrc, idx) => {
          const img = new Image();
          img.crossOrigin = 'Anonymous';
          img.onload = () => {
            // Scale down for performance
            const scale = Math.min(100 / img.width, 100 / img.height);
            canvas.width = img.width * scale;
            canvas.height = img.height * scale;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            // Extract more colors per image to capture blues, purples, greens
            const colors = extractColorsFromImage(imageData, 6);
            allColors.push(...colors);

            processed++;
            if (processed === images.length) {
              setExtractedColors(allColors);
              // Keep more colors for variation diversity (6-8 colors)
              const clustered = clusterAllColors(allColors, 8);
              setClusteredColors(clustered);

              // Generate 6 initial variations (one for each strategy)
              const initialVariations = [0, 1, 2, 3, 4, 5].map(i =>
                generateGradientVariation(clustered, i)
              ).filter(g => g !== null);
              setGradients(initialVariations);
            }
          };
          img.src = imgSrc;
        });
      }, [images]);

      const handleDrop = useCallback((e) => {
        e.preventDefault();
        setIsDragging(false);
        
        const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
        if (files.length === 0) return;

        const newImages = [];
        files.forEach(file => {
          const reader = new FileReader();
          reader.onload = (e) => {
            newImages.push(e.target.result);
            if (newImages.length === files.length) {
              setImages(prev => [...prev, ...newImages].slice(0, 10));
            }
          };
          reader.readAsDataURL(file);
        });
      }, []);

      const handleFileSelect = (e) => {
        const files = Array.from(e.target.files).filter(f => f.type.startsWith('image/'));
        if (files.length === 0) return;

        const newImages = [];
        files.forEach(file => {
          const reader = new FileReader();
          reader.onload = (e) => {
            newImages.push(e.target.result);
            if (newImages.length === files.length) {
              setImages(prev => [...prev, ...newImages].slice(0, 10));
            }
          };
          reader.readAsDataURL(file);
        });
      };

      const removeImage = (idx) => {
        setImages(prev => prev.filter((_, i) => i !== idx));
      };

      const clearAll = () => {
        setImages([]);
      };

      const generateMoreVariations = () => {
        const currentCount = gradients.length;
        const newVariations = [0, 1].map(i =>
          generateGradientVariation(clusteredColors, currentCount + i)
        ).filter(g => g !== null);
        setGradients(prev => [...prev, ...newVariations]);
      };

      const toggleExport = (gradientId) => {
        setGradients(prev => prev.map(g =>
          g.id === gradientId ? { ...g, isExpanded: !g.isExpanded } : g
        ));
      };

      const deleteVariation = (gradientId) => {
        setGradients(prev => prev.filter(g => g.id !== gradientId));
      };

      const updateActiveTab = (gradientId, tab) => {
        setGradients(prev => prev.map(g =>
          g.id === gradientId ? { ...g, activeTab: tab } : g
        ));
      };

      return (
        <div className="min-h-screen">
          {/* Hidden canvas for color extraction */}
          <canvas ref={canvasRef} className="hidden" />
          
          {/* Header */}
          <header className="border-b border-[#E8E8E5] bg-white">
            <div className="max-w-6xl mx-auto px-6 py-4 flex items-center justify-between">
              <div>
                <h1 className="text-sm font-medium text-[#0B241C]">YIR Gradient Generator</h1>
                <p className="text-xs text-[#9AB3A9]">Year in Review Campaign Toolkit</p>
              </div>
              {images.length > 0 && (
                <button
                  onClick={clearAll}
                  className="text-xs text-[#9AB3A9] hover:text-[#4A7561] transition-colors"
                >
                  Clear all
                </button>
              )}
            </div>
          </header>

          <main className="max-w-7xl mx-auto px-6 py-8">
            {/* Input Section - Full Width */}
            <div className="space-y-6 mb-8">
              {/* Drop Zone */}
              <div
                className={`drop-zone border-2 border-dashed border-[#E8E8E5] rounded-lg p-8 text-center cursor-pointer transition-all ${isDragging ? 'dragging' : ''}`}
                onDragOver={(e) => { e.preventDefault(); setIsDragging(true); }}
                onDragLeave={() => setIsDragging(false)}
                onDrop={handleDrop}
                onClick={() => fileInputRef.current?.click()}
              >
                <input
                  ref={fileInputRef}
                  type="file"
                  multiple
                  accept="image/*"
                  className="hidden"
                  onChange={handleFileSelect}
                />
                <p className="text-sm text-[#4A7561]">
                  {images.length === 0
                    ? 'Drop theme card images here'
                    : `${images.length}/10 images`}
                </p>
                <p className="text-xs text-[#9AB3A9] mt-1">6-10 images recommended</p>
              </div>

              {/* Image Thumbnails */}
              {images.length > 0 && (
                <div className="grid grid-cols-10 gap-2">
                  {images.map((src, idx) => (
                    <div key={idx} className="relative group aspect-square">
                      <img
                        src={src}
                        className="w-full h-full object-cover rounded"
                        alt={`Card ${idx + 1}`}
                      />
                      <button
                        onClick={() => removeImage(idx)}
                        className="absolute top-1 right-1 w-5 h-5 bg-black/50 text-white rounded-full text-xs opacity-0 group-hover:opacity-100 transition-opacity"
                      >
                        ×
                      </button>
                    </div>
                  ))}
                </div>
              )}

              {/* Extracted Colors */}
              {clusteredColors.length > 0 && (
                <div className="space-y-3">
                  <p className="text-xs text-[#9AB3A9] uppercase tracking-wide">Extracted Palette</p>
                  <div className="flex gap-2">
                    {clusteredColors.map((color, idx) => (
                      <div
                        key={idx}
                        className="w-12 h-12 rounded border border-black/10"
                        style={{ backgroundColor: color.hex }}
                        title={`${color.name || color.hex}`}
                      />
                    ))}
                  </div>
                </div>
              )}

              {/* Generate More Button */}
              {gradients.length > 0 && (
                <button
                  onClick={generateMoreVariations}
                  className="w-full px-4 py-3 bg-[#11362A] text-white rounded-lg hover:bg-[#1a4a3a] transition-colors text-sm font-medium"
                >
                  Generate More Variations
                </button>
              )}
            </div>

            {/* Gradient Cards Grid */}
            {gradients.length > 0 && (
              <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-6">
                {gradients.map(gradient => (
                  <GradientCard
                    key={gradient.id}
                    gradient={gradient}
                    onToggleExport={toggleExport}
                    onDelete={deleteVariation}
                    onTabChange={updateActiveTab}
                  />
                ))}
              </div>
            )}
          </main>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<GradientGenerator />);
  </script>
</body>
</html>
